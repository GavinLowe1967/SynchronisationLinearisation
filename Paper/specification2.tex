\subsection{Variations}
\label{ssec:spec-variations}

Above we considered heterogeneous binary synchronisations,
i.e.~synchronisations between \emph{two} executions of \emph{different}
operations, with a single mode of synchronisation.  In this section, we
generalise.  There are two aspects of this: defining the effect of a
synchronisation, via a synchronisation specification object; and defining
which operations of the synchronisation object can synchronise together, and
relating them to the corresponding operation of the synchronisation
specification object.

It is straightforward to generalise to synchronisations between an arbitrary
number of operation executions, some of which might be executions of the same
operation.  Consider a $k$-way synchronisation between operations
\begin{scala}
def op£\s j£(x£\s j£: A£\s j£): B£\s j£   £for $j = 1, \ldots, k,$£
\end{scala}
%
where the $\op_j$ might not be distinct.
The specification object will have a corresponding operation of the form
%
\begin{scala} 
def sync(x£\s1£: A£\s1£, ..., x£\s k£: A£\s k£): (B£\s1£, ..., B£\s k£)
\end{scala}
%
For example, for the combining barrier |CombiningBarrier(n, f)| of the
Introduction, the corresponding specification object would be\footnote{We
  change the name of the operation to~{\scalashape syncA}, to avoid a
  name-clash with the operation {\scalashape sync} of {\scalashape
    CombiningBarrier}.}   
% [A](n: Int, f: (A,A) => A)
\begin{scala}
class CombiningBarrierSpec{
  def syncA((id£\s1£,x£\s1£): (Int,A) ..., (id£\s{\ss n}£,x£\s{\ss n}£): (Int,A)) = {
    val result = f(x£\s1£, f(x£\s2£,...f(x£\s{{\ss{n}}-1}£, x£\s{\ss n}£)...)); (result,...,result)
  }
}
\end{scala}

We define the relationship between operations of the synchronisation object
and of the synchronisation specification object via a \emph{synchronisation
  abstraction function}: this is a partial function that maps a (non-empty)
sequence of operations of the synchronisation object to the corresponding
operation of the synchronisation specification object.  For the combining
barrier, the abstraction function is
\[
\begin{align}
\set{ 
  \seq{ \sm{sync}((id_1,x_1)), \ldots, \sm{sync}((id_{\ss n},x_{\ss n})) } \mapsto
  \sm{syncA}((id_1,x_1), \ldots, (id_{\ss n},x_{\ss n})) 
 \midd \\
\qquad id_1, \ldots id_{\ss n} \in \sm{Int}, x_1,\ldots,x_{\ss n} \in \sm A
}.
\end{align}
\]
%% (The former |sync|s represent the operation in |CombiningBarrier|,
%% and the latter |sync| represents the operation of the same name in
%% |Combining|\-|Barrier|\-|Spec|.) 

For the generic binary synchronisations we considered in
Section~\ref{sec:sync-lin}, the abstraction function is
\[
\set{ \seq{\op_1(x_1), \op_2(x_2)} \mapsto \sync(x_1,x_2) \midd 
  x_1 \in \sm A_1, x_2 \in \sm A_2 }.
\]

For a synchronisation object with multiple modes of synchronisation, the
synchronisation specification object has a different operation for each mode.
For example, recall the |TimeoutChannel| from the Introduction, where sends
and receives may timeout and return without synchronisation.  The
corresponding specification object is as follows (we omit arguments of
type~|Unit|, to improve readability).
%
\begin{scala}
class TimeoutChannelSpec[A]{
  def sendTO(x: A) = false       // £send£ times out.
  def receiveTO() = None  // £receive£ times out.
  def sync(x: A) = (true, Some(x))  // Synchronisation.
}
\end{scala}
%
The operation |sendTO| corresponds to a |send| timing out (and so not
synchronising), |receiveTO| corresponds to a |receive| timing out, and
|sync| corresponds to a |send| and |receive| synchronising.  This is
formalised by the synchronisation abstraction function:
\[
\begin{align}
\set{ \seq{ \sm{send}(x) } \mapsto \sm{sendTO}(x)  \midd x \in \sm A } \union{} 
\set{ \seq{ \sm{receive}() } \mapsto \sm{receiveTO}()  } \union{}  \\
\set{ ( \seq{ \sm{send}(x), \sm{receive}() } \mapsto \sm{sync}(x) \midd
      x \in \sm A }.
\end{align}
\]

As another example, the following is a specification object for a channel with
a close operation.
%
%\begin{mysamepage}
\begin{scala}
class ClosableChannelSpec[A]{
  private var isClosed = false  // Is the channel closed? 
  def close() = { isClosed = true; () }
  def sync(x: A) = { require(!isClosed); ((), x) }
  def sendFail(x: A) = { require(isClosed); throw new Closed }
  def receiveFail() = { require(isClosed); throw new Closed }
}
\end{scala}
%\end{mysamepage}
%
The synchronisation abstraction function is
\[
\begin{align}
\set{ \seq{\sm{close}()} \mapsto \sm{close}() }  \union 
\set{ \seq{ \sm{send}(x), \sm{receive}() } \mapsto \sm{sync}(x) \midd
      x \in \sm A } \union\null \\
\set{ \seq{ \sm{send}(x) } \mapsto \sm{sendFail}(x)  
  \midd x \in \sm A } \union{} 
\set{ \seq{ \sm{receive}() } \mapsto \sm{receiveFail}()  }.
\end{align}
\]
A |send| and |receive| can synchronise corresponding to |sync|, but only before
the channel is closed; or each may fail once the channel is closed,
corresponding to |sendFail| and |receiveFail|.  

We now describe how to generalise the definition of synchronisation
linearisation.  Fix a synchronisation specification object $Spec$ and
corresponding synchronisation abstraction function~$\A$.  For each operation
\begin{scala}
  def £$sync$£(x£\s 1£: A£\s 1£,...,x£\s n£: A£\s k£): (B£\s 1£,...,B£\s k£) 
\end{scala}
of $Spec$ (corresponding to $k$ threads synchronising), we introduce events
$sync^{i_1, \ldots, i_k}(x_1, \ldots, x_k)\:: (y_1, \ldots, y_k)$ (where,
for each~$j$,\, $x_j \in A_j$,\, $y_j \in B_j$, and $i_j$ is an execution
identity).  A legal history of $Spec$ is then a sequence of such events,
consistent with the definition of $Spec$.

\begin{definition}
\label{def:sync-lin}
Let $h$ be a complete history of the synchronisation object.  Then a legal
history $h_s$ of~$Spec$ corresponds to $h$ if:
\begin{itemize}
\item
For each event $sync^{i_1, \ldots, i_k}(x_1, \ldots, x_k)\:: (y_1, \ldots,
y_k)$ in~$h_s$, there is some maplet $\seq{ op_1(x_1), \ldots, op_k(x_k) } \mapsto
sync(x_1,\ldots,x_k)$ in~$\A$ such that, for
each~$j$, $h$ contains an execution of $op_j(x_j)^{i_j}\:: y_j$.

\item For each execution $op_j(x_j)^{i_j}\:: y_j$ in~$h$,\, $h_s$ contains
  some event of the form $sync^{i_1, \ldots, i_k}(x_1, \ldots, x_k)\:: (y_1,
  \ldots, y_k)$ (necessarily the abstraction function~$\A$ relates operations
  as in the previous bullet point).
\end{itemize}
%
Then $h_s$ is a synchronisation linearisation of~$h$ if there is some way of
interleaving $h$ and~$h_s$ such that each event $sync^{i_1, \ldots, i_k}(x_1,
\ldots, x_k)\:: (y_1, \ldots, y_k)$ is between $\call.op_j^{i_j}(x_j)$
and $\return.op_j^{i_j}\::y_j$, for each~$j$. 
\end{definition}

The definition of synchronisation linearisability then follows precisely as in
Definition~\ref{def:sync-lin-objects}.

%%%%%%%%%% 

\label{sec:set-lin-comparison}
As noted in the Introduction, our notion of synchronisation linearisation is
equivalent to \emph{set linearisation}~\cite{Neiger-1994}, although no formal
definition was given there. 

The same property was rediscovered by Hemed et al.~\cite{HRV-2015}, and called
\emph{concurrency-aware linearisation} (CAL).  They define a concurrency-aware
trace (CA-trace) to be a history of \emph{sets} of operation executions, where
each set represents operation executions that seem to take effect
simultaneously (such as those in a synchronisation).  For the example of
Figure~\ref{fig:sync-timeline}, the CA-trace would be
\[
\begin{align}
\seq{ \set{\sm{send}^1(8)\::(), \sm{receive}^3(())\::8},
  \set{ \sm{send}^5(9)\::(), \sm{receive}^4(())\::9 }, \\
\qquad
  \set{ \sm{send}^2(8)\::(), \sm{receive}^6(())\::8 } }.
\end{align}
\]
%% (Compared with our approach, applying a synchronisation abstraction function
%% to such a CA-trace would produce a history of a synchronisation specification
%% object.)  
Hemed et al.~define a complete history~$h$ to \emph{agree} with a CA-trace
$h_s$ if, for all operations $op_1$ and~$op_2$, if $\return.op_1$ is before
$\call.op_2$ in~$h$, then in~$h_s$, the set that contains~$op_1$ is before the
set that contains~$op_2$.  (This is equivalent to a definition, similar to
ours, based on interleaving~$h$ and~$h_s$.)  They define a concurrent object
to be CA-linearisable with respect to a set $S$ of CA-traces if, for every
history~$h$ of the object, there is an extension~$h'$ of~$h$ and a history
$h_s \in S$ such that $complete(h')$ agrees with~$h_s$.  This is equivalent to
our definition when $S$ is taken to be the inverse image under the
synchronisation abstraction function of all histories of the synchronisation
specification object.
%
Unlike us, they do not provide a way of specifying correct CA-traces,
comparable to our synchronisation specification objects: they simply assume a
given set of correct CA-traces.  They verify an exchanger object with respect
to CAL, and then use this result in a modular verification of an elimination
stack~\cite{HSY-2004}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Locality}
\label{sec:locality}

So far, we have implicitly assumed a single synchronisation object.  However,
a program may employ multiple synchronisation objects.  Consider a set of
independent synchronisation objects~$\O$.  Given a history~$h$ and an
object~$o$, we write $h \restrict o$ for the restriction of $h$ to events
of~$o$.  We assume that the objects are independent, so $h$ is a history
of~$\O$ if and only if $h \restrict o$ is a history of~$o$ for each~$o$. 

We assume that each synchronisation object~$o$ has its own synchronisation
specification object $Spec_o$ and abstraction function~$\A_o$.  We can combine
the specification objects into a single specification object~$Spec$, with the
operations of all $Spec_o$ (assumed distinct): a history~$h_s$ is legal if and
only if $h_s \restrict Spec_o$ is legal for each $Spec_o$.  Likewise we can
combine the abstraction functions into a single abstraction function~$\A$, by
taking their union.

We show that synchronisation linearisation satisfies a locality property: the
combined objects~$\O$ are  synchronisation-linearisable if and only if each
individual object is synchronisation-linearisable.  This is an important
result, as it allows for compositional development and verification.
(Neiger~\cite{Neiger-1994} states a similar result.)

\begin{lemma}
\label{lem:local}
Let $h$ be a complete history of the synchronisation objects~$\O$.
Then $h$ is synchronisation-linearisable (with respect to $Spec$ and~$\A$) if
and only if $h \restrict o$ is synchronisation-linearisable (with respect to
$Spec_o$ and $\A_o$), for each~$o \in \O$.
%% , and $h_s$ a legal history~$h_s$ of~$Spec$.  Then $h_s$ is a
%% synchronisation linearisation of~$h$ if and only if $h_s \restrict Spec_o$
%% is a synchronisation-linearisable of $h \restrict o$, for each~$o$.
\end{lemma}

\begin{proof}
The left-to-right implication is straightforward.  

For the right-to-left implication, suppose that $h \restrict o$ is
synchronisation-linearisable, for each~$o$.  That means that there is a legal
history~$h_{s_o}$ of~$Spec_o$ that is a synchronisation linearisation of~$h
\restrict o$.  Write $h^I_o$ for the interleaving of these histories that
demonstrates this (following Definition~\ref{def:sync-lin}).

We build an interleaving~$h^I$ of~$h$ and all $h_{s_o}$ for $o \in \O$,
consistent with the $h^I_o$ interleavings: if, in~$h^I_o$, a $\call$ or
$\return$ event~$e$ of~$o$ is followed by events $s_1,\ldots,s_k$ of
$h_{s_o}$, then we insert $s_1,\ldots,s_k$ into~$h$ directly after~$e$.

In the resulting interleaving~$h^I$, each synchronisation event is still
between the relevant $\call$ and $\return$ events, by construction.  Let $h_s$
be the restriction of~$h^I$ to the events of the specification
objects.  Then for each~$o$,\, $h_s \restrict Spec_o = h_{s_o}$, by
construction, so is legal.  Hence $h_s$ is legal.
\end{proof}

\begin{prop}
The collection of objects~$\O$ is synchronisation-linearisable (with respect
to $Spec$ and~$\A$) if and only if $o$ is synchronisation-linearisable (with
respect to~$Spec_o$ and $\A_o$), for each $o \in \O$.
\end{prop}
%
\begin{proof}
The left-to-right implication is again straightforward.  

For the right-to-left implication, consider a (not necessarily complete)
history~$h$ of~$\O$.  For each $o$, since $o$ is synchronisation-linearisable,
there is an extension $h_o'$ of $h \restrict o$ such that $complete(h_o')$ is
synchronisation-linearisable with respect to $Spec_o$ and~$\A_o$.
%
Let $h'$ be an extension of~$h$, adding the events in each~$h_o'$ but not~$h
\restrict o$ in the same order (but interleaving events from different objects
arbitrarily).  Then $complete(h') \restrict o = complete(h_o')$, for each~$o$.
%
Also, $complete(h')$ is a complete history of~$\O$, and by
Lemma~\ref{lem:local}, $complete(h')$ is synchronisation-linearisable with
respect to~$Spec$ and~$\A$, as required.
\end{proof}

