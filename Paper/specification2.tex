\subsection{Variations}
\label{ssec:spec-variations}

Above we considered heterogeneous binary synchronisations,
i.e.~synchronisations between \emph{two} executions of \emph{different}
operations, with a single mode of synchronisation.  In this section, we
generalise.  There are two aspects of this: defining the effect of a
synchronisation, via a synchronisation specification object; and defining
which operations of the synchronisation object can synchronise together, and
relating them to the corresponding operation of the synchronisation
specification object.

It is straightforward to generalise to synchronisations between an arbitrary
number of operation executions, some of which might be executions of the same
operation.  Consider a $k$-way synchronisation between operations
\begin{scala}
def op£\s j£(x£\s j£: A£\s j£): B£\s j£   £for $j = 1, \ldots, k,$£
\end{scala}
%
where the $\op_j$ might not be distinct.
The specification object will have a corresponding operation of the form
%
\begin{scala} 
def sync(x£\s1£: A£\s1£, ..., x£\s k£: A£\s k£): (B£\s1£, ..., B£\s k£)
\end{scala}
%
For example, for the combining barrier |CombiningBarrier(n, f)| of the
Introduction, the corresponding specification object would be\footnote{We
  change the name of the operation to~{\scalashape syncA}, to avoid a
  name-clash with the operation {\scalashape sync} of {\scalashape
    CombiningBarrier}.}   
% [A](n: Int, f: (A,A) => A)
\begin{scala}
class CombiningBarrierSpec{
  def syncA((id£\s1£,x£\s1£): (Int,A) ..., (id£\s{\ss n}£,x£\s{\ss n}£): (Int,A)) = {
    val result = f(x£\s1£, f(x£\s2£,...f(x£\s{{\ss{n}}-1}£, x£\s{\ss n}£)...)); (result,...,result)
  }
}
\end{scala}

We define the relationship between operations of the synchronisation object
and of the synchronisation specification object via a \emph{synchronisation
  abstraction function}: this is a partial function that maps a (non-empty)
sequence of operations of the synchronisation object to the corresponding
operation of the synchronisation specification object.  For the combining
barrier, the abstraction function is
\[
\begin{align}
\set{ 
  \seq{ \sm{sync}((id_1,x_1)), \ldots, \sm{sync}((id_{\ss n},x_{\ss n})) } \mapsto
  \sm{syncA}((id_1,x_1), \ldots, (id_{\ss n},x_{\ss n})) 
 \midd \\
\qquad id_1, \ldots id_{\ss n} \in \sm{Int}, x_1,\ldots,x_{\ss n} \in \sm A
}.
\end{align}
\]
%% (The former |sync|s represent the operation in |CombiningBarrier|,
%% and the latter |sync| represents the operation of the same name in
%% |Combining|\-|Barrier|\-|Spec|.) 

For the generic binary synchronisations we considered in
Section~\ref{sec:sync-lin}, the abstraction function is
\[
\set{ \seq{\op_1(x_1), \op_2(x_2)} \mapsto \sync(x_1,x_2) \midd 
  x_1 \in \sm A_1, x_2 \in \sm A_2 }.
\]

For a synchronisation object with multiple modes of synchronisation, the
synchronisation specification object has a different operation for each mode.
For example, recall the |TimeoutChannel| from the Introduction, where sends
and receives may timeout and return without synchronisation.  The
corresponding specification object is as follows (we omit arguments of
type~|Unit|, to improve readability).
%
\begin{scala}
class TimeoutChannelSpec[A]{
  def sendTO(x: A) = false       // £send£ times out.
  def receiveTO() = None  // £receive£ times out.
  def sync(x: A) = (true, Some(x))  // Synchronisation.
}
\end{scala}
%
The operation |sendTO| corresponds to a send timing out (and so not
synchronising), |receiveTO| corresponds to a receive timing out, and
|sync| corresponds to a send and receive synchronising.  This is
formalised by the synchronisation abstraction function:
\[
\begin{align}
\set{ \seq{ \sm{send}(x) } \mapsto \sm{sendTO}(x)  \midd x \in \sm A } \union{} 
\set{ \seq{ \sm{receive}() } \mapsto \sm{receiveTO}()  } \union{}  \\
\set{ ( \seq{ \sm{send}(x), \sm{receive}() } \mapsto \sm{sync}(x) \midd
      x \in \sm A }.
\end{align}
\]

As another example, the following is a specification object for a channel with
a close operation.
%
%\begin{mysamepage}
\begin{scala}
class ClosableChannelSpec[A]{
  private var isClosed = false  // Is the channel closed? 
  def close() = { isClosed = true; () }
  def sync(x: A) = { require(!isClosed); ((), x) }
  def sendFail(x: A) = { require(isClosed); throw new Closed }
  def receiveFail() = { require(isClosed); throw new Closed }
}
\end{scala}
%\end{mysamepage}
%
The synchronisation abstraction function is
\[
\begin{align}
\set{ \seq{\sm{close}()} \mapsto \sm{close}() }  \union 
\set{ \seq{ \sm{send}(x), \sm{receive}() } \mapsto \sm{sync}(x) \midd
      x \in \sm A } \union\null \\
\set{ \seq{ \sm{send}(x) } \mapsto \sm{sendFail}(x)  
  \midd x \in \sm A } \union{} 
\set{ \seq{ \sm{receive}() } \mapsto \sm{receiveFail}()  }.
\end{align}
\]
A send and receive can synchronise corresponding to |sync|, but only before
the channel is closed; or each may fail once the channel is closed,
corresponding to |sendFail| and |receiveFail|.  

We now describe how to generalise the definition of synchronisation
linearisation.  Fix a synchronisation specification object $Spec$ and
corresponding synchronisation abstraction function~$\A$.  For each operation
\begin{scala}
  def £$sync$£(x£\s 1£: A£\s 1£,...,x£\s n£: A£\s k£): (B£\s 1£,...,B£\s k£) 
\end{scala}
of $Spec$ (corresponding to $k$ threads synchronising), we introduce events
$sync^{i_1, \ldots, i_k}(x_1, \ldots, x_k)\:: (y_1, \ldots, y_k)$ (where,
for each~$j$,\, $x_j \in A_j$,\, $y_j \in B_j$, and $i_j$ is an execution
identity).  A legal history of $Spec$ is then a sequence of such events,
consistent with the definition of $Spec$.

\begin{definition}
\label{def:sync-lin}
Let $h$ be a complete history of the synchronisation object.  Then a legal
history $h_s$ of~$Spec$ corresponds to $h$ if:
\begin{itemize}
\item
For each event $sync^{i_1, \ldots, i_k}(x_1, \ldots, x_k)\:: (y_1, \ldots,
y_k)$ in~$h_s$, there is some maplet $\seq{ op_1(x_1), \ldots, op_k(x_k) } \mapsto
sync(x_1,\ldots,x_k)$ in~$\A$ such that, for
each~$j$, $h$ contains an execution of $op_j(x_j)^{i_j}\:: y_j$.

\item For each execution $op_j(x_j)^{i_j}\:: y_j$ in~$h$,\, $h_s$ contains
  some event of the form $sync^{i_1, \ldots, i_k}(x_1, \ldots, x_k)\:: (y_1,
  \ldots, y_k)$ (necessarily the abstraction function~$\A$ relates operations
  as in the previous bullet point).
\end{itemize}
%
Then $h_s$ is a synchronisation linearisation of~$h$ if there is some way of
interleaving $h$ and~$h_s$ such that each event $sync^{i_1, \ldots, i_k}(x_1,
\ldots, x_k)\:: (y_1, \ldots, y_k)$ is between $\call.op_j^{i_j}(x_j)$
and $\return.op_j^{i_j}\::y_j$, for each~$j$. 
\end{definition}

The definition of synchronisation-linearisability follows in the obvious
way.

%% %
%% The definition of synchronisation linearisation is an obvious adaptation of
%% the earlier definition: in the interleaving of the complete history of the
%% synchronisation history and the history of the specification object, each
%% $\sm{sync}^{i_1, \ldots, i_k}(x_1, \ldots, x_k)\:: (y_1, \ldots, y_k)$ occurs
%% between $\call.\op_1^{i_j}(x_j)$ and $\return.\op_j^{i_j}\::y_j$ for each $j =
%% 1, \ldots, k$.
%% %% The definition of synchronisation-linearisability follows in the obvious
%% %% way.

%% Note that if several of the $\op_j$ are the same operation, there is a choice
%% as to the order in which their parameters are passed to |sync|.  (However, in
%% the case of the combining barrier, if |f| is associative and commutative, the
%% order makes no difference.)

%% It is also straightforward to adapt the definitions to deal with multiple
%% modes of synchronisation: the specification object has a different operation
%% for each mode.  For example, recall the |TimeoutChannel| from the
%% Introduction, where sends and receives may timeout and return without
%% synchronisation.  The corresponding specification object would be:
%% %
%% \begin{scala}
%% class TimeoutChannelSpec[A]{
%%   def sync£\s s£(x: A) = false       // £send£ times out.
%%   def sync£\s r£(u: Unit) = None  // £receive£ times out.
%%   def sync£\s{s,r}£(x: A, u: Unit) = (true, Some(x))  // Synchronisation.
%% }
%% \end{scala}
%% %
%% The operation $\sm{sync}_s$ corresponds to a send returning without
%% synchronising; likewise $\sm{sync}_r$ corresponds to a receive returning
%% without synchronising; and $\sm{sync}_{s,r}$ corresponds to a send and receive
%% synchronising.  The formal definition of synchronisation linearisation is the
%% obvious adaptation of the earlier definition: in particular |sync|\s{s} must
%% occur between the call and return of a send that doesn't synchronise, and
%% likewise for |sync|\s{r}.

%% As another example, the following is a specification object for a channel with
%% a close operation.
%% %
%% \begin{mysamepage}
%% \begin{scala}
%% class ClosableChannelSpec[A]{
%%   private var isClosed = false  // Is the channel closed? 
%%   def close(u: Unit) = { isClosed = true; () }
%%   def sync(x: A, u: Unit) = { require(!isClosed); ((), x) }
%%   def sendFail(x: A) = { require(isClosed); throw new Closed }
%%   def receiveFail(u: Unit) = { require(isClosed); throw new Closed }
%% }
%% \end{scala}
%% \end{mysamepage}
%% %
%% A send and receive can synchronise corresponding to |sync|, but only before
%% the channel is closed; or each may fail once the channel is closed,
%% corresponding to |sendFail| and |receiveFail|. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Locality}
\label{sec:locality}

So far, we have implicitly assumed a single synchronisation object.  However,
a program may employ multiple synchronisation objects.  Consider a set of
independent synchronisation objects~$\O$.  Given a history~$h$ and an
object~$o$, we write $h \restrict o$ for the restriction of $h$ to events
of~$o$.  We assume that the objects are independent, so $h$ is a history
of~$\O$ if and only if $h \restrict o$ is a history of~$o$ for each~$o$. 

We assume that each synchronisation object~$o$ has its own synchronisation
specification object $Spec_o$ and abstraction function~$\A_o$.  We can combine
the specification objects into a single specification object~$Spec$, with the
operations of all $Spec_o$ (assumed distinct): a history~$h_s$ is legal if and
only if $h_s \restrict Spec_o$ is legal for each $Spec_o$.  Likewise we can
combine the abstraction functions into a single abstraction function~$\A$, by
taking their union.

We show that synchronisation linearisation satisfies a locality property: the
objects~$\O$ are synchronisation-linearisable if and only if each individual
object is synchronisation-linearisable.  This is an important result, as it
allows for compositional development and verification.  

\begin{lemma}
\label{lem:local}
Let $h$ be a complete history of the synchronisation objects~$\O$.
Then $h$ is synchronisation-linearisable (with respect to $Spec$ and~$\A$) if
and only if $h \restrict o$ is synchronisation-linearisable (with respect to
$Spec_o$ and $\A_o$), for each~$o \in \O$.
%% , and $h_s$ a legal history~$h_s$ of~$Spec$.  Then $h_s$ is a
%% synchronisation linearisation of~$h$ if and only if $h_s \restrict Spec_o$
%% is a synchronisation linearisable of $h \restrict o$, for each~$o$.
\end{lemma}

\begin{proof}
The left-to-right implication is trivial.  

For the right-to-left implication, suppose that $h \restrict o$ is
synchronisation-linearisable, for each~$o$.  That means that there is a legal
history~$h_{s_o}$ of~$Spec_o$ that is a synchronisation linearisation of~$h
\restrict o$.  Write $h^I_o$ for the interleaving of these histories that
demonstrates this (following Definition~\ref{def:sync-lin}).

We build an interleaving~$h^I$ of~$h$ and all $h_{s_o}$ for $o \in \O$,
consistent with the $h^I_o$ interleavings: if, in~$h^I_o$, a $\call$ or
$\return$ event~$e$ of~$o$ is followed by events $s_1,\ldots,s_k$ of
$h_{s_o}$, then we insert $s_1,\ldots,s_k$ into~$h$ directly after~$e$.

In the resulting interleaving~$h^I$, each synchronisation event is still
between the relevant $\call$ and $\return$ events, by construction.  Let $h_s$
be the restriction of~$h^I$ to the events of the specification
objects.  Then for each~$o$,\, $h_s \restrict Spec_o = h_{s_o}$, by
construction, so is legal.  Hence $h_s$ is legal.
\end{proof}

\begin{prop}
The collection of objects~$\O$ is synchronisation-linearisable (with respect
to $Spec$ and~$\A$) if and only if $o$ is synchronisation-linearisable (with
respect to~$Spec_o$ and $\A_o$), for each $o \in \O$.
\end{prop}
%
\begin{proof}
The left-to-right implication is again trivial.  

For the right-to-left implication, consider a (not necessarily complete)
history~$h$ of~$\O$.  For each $o$, since $o$ is synchronisation-linearisable,
there is an extension $h_o'$ of $h \restrict o$ such that $complete(h_o')$ is
synchronisation-linearisable with respect to $Spec_o$ and~$\A_o$.
%
Let $h'$ be an extension of~$h$, adding the events in each~$h_o'$ but
not~$h_o$ in the same order (but interleaving events from different of
different objects arbitrarily).  Then $complete(h') \restrict o =
complete(h_o')$, for each~$o$.
%
Then $complete(h')$ is a complete history of~$\O$, and by
Lemma~\ref{lem:local}, $complete(h')$ is synchronisation-linearisable with
respect to~$Spec$ and~$\A$, as required.
\end{proof}

